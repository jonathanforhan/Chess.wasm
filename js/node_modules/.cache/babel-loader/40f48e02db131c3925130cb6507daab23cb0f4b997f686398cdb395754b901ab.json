{"ast":null,"code":"/**\n * @param {string}\n * @returns {boolean}\n */\nfunction isDigit(c) {\n  return '0123456789'.indexOf(c) !== -1;\n}\n\n/**\n * @param {string}\n * @returns {ok, error}\n * taken from chess.js source code\n */\nexport function validateFen(fen) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/);\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields'\n    };\n  }\n\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10);\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer'\n    };\n  }\n\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10);\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: half move counter number must be a non-negative integer'\n    };\n  }\n\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: en-passant square is invalid'\n    };\n  }\n\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: castling availability is invalid'\n    };\n  }\n\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: side-to-move is invalid'\n    };\n  }\n\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/');\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\"\n    };\n  }\n\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0;\n    let previousWasNumber = false;\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)'\n          };\n        }\n        sumFields += parseInt(rows[i][k], 10);\n        previousWasNumber = true;\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)'\n          };\n        }\n        sumFields += 1;\n        previousWasNumber = false;\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)'\n      };\n    }\n  }\n  if (tokens[3][1] === '3' && tokens[1] === 'w' || tokens[3][1] === '6' && tokens[1] === 'b') {\n    return {\n      ok: false,\n      error: 'Invalid FEN: illegal en-passant square'\n    };\n  }\n  const kings = [{\n    color: 'white',\n    regex: /K/g\n  }, {\n    color: 'black',\n    regex: /k/g\n  }];\n  for (const {\n    color,\n    regex\n  } of kings) {\n    if (!regex.test(tokens[0])) {\n      return {\n        ok: false,\n        error: `Invalid FEN: missing ${color} king`\n      };\n    }\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return {\n        ok: false,\n        error: `Invalid FEN: too many ${color} kings`\n      };\n    }\n  }\n  return {\n    ok: true\n  };\n}","map":{"version":3,"names":["isDigit","c","indexOf","validateFen","fen","tokens","split","length","ok","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","i","sumFields","previousWasNumber","k","kings","color","regex","match"],"sources":["/home/jon/dev/shallow_blue/test/client/src/logic/Validation.js"],"sourcesContent":["/**\n * @param {string}\n * @returns {boolean}\n */ \nfunction isDigit(c) {\n  return '0123456789'.indexOf(c) !== -1\n}\n\n/**\n * @param {string}\n * @returns {ok, error}\n * taken from chess.js source code\n */\nexport function validateFen(fen) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/)\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields',\n    }\n  }\n\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10)\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer',\n    }\n  }\n\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10)\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error:\n        'Invalid FEN: half move counter number must be a non-negative integer',\n    }\n  }\n\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return { ok: false, error: 'Invalid FEN: en-passant square is invalid' }\n  }\n\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return { ok: false, error: 'Invalid FEN: castling availability is invalid' }\n  }\n\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return { ok: false, error: 'Invalid FEN: side-to-move is invalid' }\n  }\n\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/')\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n    }\n  }\n\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0\n    let previousWasNumber = false\n\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)',\n          }\n        }\n        sumFields += parseInt(rows[i][k], 10)\n        previousWasNumber = true\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)',\n          }\n        }\n        sumFields += 1\n        previousWasNumber = false\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n      }\n    }\n  }\n\n  if (\n    (tokens[3][1] === '3' && tokens[1] === 'w') ||\n    (tokens[3][1] === '6' && tokens[1] === 'b')\n  ) {\n    return { ok: false, error: 'Invalid FEN: illegal en-passant square' }\n    }\n\n  const kings = [\n    { color: 'white', regex: /K/g },\n    { color: 'black', regex: /k/g },\n  ]\n\n  for (const { color, regex } of kings) {\n    if (!regex.test(tokens[0])) {\n      return { ok: false, error: `Invalid FEN: missing ${color} king` }\n    }\n\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return { ok: false, error: `Invalid FEN: too many ${color} kings` }\n    }\n  }\n\n  return { ok: true }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}