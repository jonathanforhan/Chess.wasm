{"ast":null,"code":"/* \n * Chess Logic component to the react-chessboard\n * fast, minimal piece validation\n *\n * implements only necessary methods as defined by react-chessboard docs to be a proper interface\n * implements the 0x88 hex bitshifting method for piece validation\n *\n * This was made because the chess.js engine would not work for me\n *\n */\n\nconst hexMap = new Map([[\"a8\", 70], [\"b8\", 71], [\"c8\", 72], [\"d8\", 73], [\"e8\", 74], [\"f8\", 75], [\"g8\", 76], [\"h8\", 77], [\"a7\", 60], [\"b7\", 61], [\"c7\", 62], [\"d7\", 63], [\"e7\", 64], [\"f7\", 65], [\"g7\", 66], [\"h7\", 67], [\"a6\", 50], [\"b6\", 51], [\"c6\", 52], [\"d6\", 53], [\"e6\", 54], [\"f6\", 55], [\"g6\", 56], [\"h6\", 57], [\"a5\", 40], [\"b5\", 41], [\"c5\", 42], [\"d5\", 43], [\"e5\", 44], [\"f5\", 45], [\"g5\", 46], [\"h5\", 47], [\"a4\", 30], [\"b4\", 31], [\"c4\", 32], [\"d4\", 33], [\"e4\", 34], [\"f4\", 35], [\"g4\", 36], [\"h4\", 37], [\"a3\", 20], [\"b3\", 21], [\"c3\", 22], [\"d3\", 23], [\"e3\", 24], [\"f3\", 25], [\"g3\", 26], [\"h3\", 27], [\"a2\", 10], [\"b2\", 11], [\"c2\", 12], [\"d2\", 13], [\"e2\", 14], [\"f2\", 15], [\"g2\", 16], [\"h2\", 17], [\"a1\", 0], [\"b1\", 1], [\"c1\", 2], [\"d1\", 3], [\"e1\", 4], [\"f1\", 5], [\"g1\", 6], [\"h1\", 7]]);\n\n/**\n * @param {string}\n * @returns {ok, error}\n */\nfunction validateFen(fen) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/);\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields'\n    };\n  }\n\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10);\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer'\n    };\n  }\n\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10);\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: half move counter number must be a non-negative integer'\n    };\n  }\n\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: en-passant square is invalid'\n    };\n  }\n\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: castling availability is invalid'\n    };\n  }\n\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: side-to-move is invalid'\n    };\n  }\n\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/');\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\"\n    };\n  }\n\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0;\n    let previousWasNumber = false;\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)'\n          };\n        }\n        sumFields += parseInt(rows[i][k], 10);\n        previousWasNumber = true;\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)'\n          };\n        }\n        sumFields += 1;\n        previousWasNumber = false;\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)'\n      };\n    }\n  }\n  if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n    return {\n      ok: false,\n      error: 'Invalid FEN: illegal en-passant square'\n    };\n  }\n  const kings = [{\n    color: 'white',\n    regex: /K/g\n  }, {\n    color: 'black',\n    regex: /k/g\n  }];\n  for (const {\n    color,\n    regex\n  } of kings) {\n    if (!regex.test(tokens[0])) {\n      return {\n        ok: false,\n        error: `Invalid FEN: missing ${color} king`\n      };\n    }\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return {\n        ok: false,\n        error: `Invalid FEN: too many ${color} kings`\n      };\n    }\n  }\n  return {\n    ok: true\n  };\n}\n\n/**\n * @param {number, number}\n * @returns {boolean}\n */\nfunction validateMove(_ref) {\n  let {\n    src,\n    dst\n  } = _ref;\n}\nexport class Chess {\n  /**\n   * @param {string} Starting position, default if none\n   */\n  constructor(fen) {\n    this.fen = fen;\n  }\n  /**\n   * @param {string, string}\n   * @returns {boolean}\n   */\n  move(_ref2) {\n    let {\n      src,\n      dst\n    } = _ref2;\n    src = hexMap.get(src);\n    dst = hexMap.get(dst);\n  }\n}","map":{"version":3,"names":["hexMap","Map","validateFen","fen","tokens","split","length","ok","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","i","sumFields","previousWasNumber","k","isDigit","kings","color","regex","match","validateMove","src","dst","Chess","constructor","move","get"],"sources":["/home/jon/dev/shallow_blue/test/client/src/logic/Chess.js"],"sourcesContent":[" /* \n  * Chess Logic component to the react-chessboard\n  * fast, minimal piece validation\n  *\n  * implements only necessary methods as defined by react-chessboard docs to be a proper interface\n  * implements the 0x88 hex bitshifting method for piece validation\n  *\n  * This was made because the chess.js engine would not work for me\n  *\n  */\n\nconst hexMap = new Map([\n  [\"a8\",70],[\"b8\",71],[\"c8\",72],[\"d8\",73],[\"e8\",74],[\"f8\",75],[\"g8\",76],[\"h8\",77],\n  [\"a7\",60],[\"b7\",61],[\"c7\",62],[\"d7\",63],[\"e7\",64],[\"f7\",65],[\"g7\",66],[\"h7\",67],\n  [\"a6\",50],[\"b6\",51],[\"c6\",52],[\"d6\",53],[\"e6\",54],[\"f6\",55],[\"g6\",56],[\"h6\",57],\n  [\"a5\",40],[\"b5\",41],[\"c5\",42],[\"d5\",43],[\"e5\",44],[\"f5\",45],[\"g5\",46],[\"h5\",47],\n  [\"a4\",30],[\"b4\",31],[\"c4\",32],[\"d4\",33],[\"e4\",34],[\"f4\",35],[\"g4\",36],[\"h4\",37],\n  [\"a3\",20],[\"b3\",21],[\"c3\",22],[\"d3\",23],[\"e3\",24],[\"f3\",25],[\"g3\",26],[\"h3\",27],\n  [\"a2\",10],[\"b2\",11],[\"c2\",12],[\"d2\",13],[\"e2\",14],[\"f2\",15],[\"g2\",16],[\"h2\",17],\n  [\"a1\", 0],[\"b1\", 1],[\"c1\", 2],[\"d1\", 3],[\"e1\", 4],[\"f1\", 5],[\"g1\", 6],[\"h1\", 7]\n])\n\n/**\n * @param {string}\n * @returns {ok, error}\n */\nfunction validateFen(fen) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/)\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields',\n    }\n  }\n\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10)\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer',\n    }\n  }\n\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10)\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error:\n        'Invalid FEN: half move counter number must be a non-negative integer',\n    }\n  }\n\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return { ok: false, error: 'Invalid FEN: en-passant square is invalid' }\n  }\n\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return { ok: false, error: 'Invalid FEN: castling availability is invalid' }\n  }\n\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return { ok: false, error: 'Invalid FEN: side-to-move is invalid' }\n  }\n\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/')\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n    }\n  }\n\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0\n    let previousWasNumber = false\n\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)',\n          }\n        }\n        sumFields += parseInt(rows[i][k], 10)\n        previousWasNumber = true\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)',\n          }\n        }\n        sumFields += 1\n        previousWasNumber = false\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n      }\n    }\n  }\n\n  if (\n    (tokens[3][1] == '3' && tokens[1] == 'w') ||\n    (tokens[3][1] == '6' && tokens[1] == 'b')\n  ) {\n    return { ok: false, error: 'Invalid FEN: illegal en-passant square' }\n    }\n\n  const kings = [\n    { color: 'white', regex: /K/g },\n    { color: 'black', regex: /k/g },\n  ]\n\n  for (const { color, regex } of kings) {\n    if (!regex.test(tokens[0])) {\n      return { ok: false, error: `Invalid FEN: missing ${color} king` }\n    }\n\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return { ok: false, error: `Invalid FEN: too many ${color} kings` }\n    }\n  }\n\n  return { ok: true }\n}\n\n/**\n * @param {number, number}\n * @returns {boolean}\n */\nfunction validateMove({src, dst}) {\n  \n}\n\nexport class Chess {\n  /**\n   * @param {string} Starting position, default if none\n   */\n  constructor(fen) {\n    this.fen = fen;\n  }\n  /**\n   * @param {string, string}\n   * @returns {boolean}\n   */\n  move({src, dst}) {\n    src = hexMap.get(src);\n    dst = hexMap.get(dst);\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}